name: "Shai-Hulud Scanner"
description: "Scan lockfiles for compromised packages using shai-hulud-scanner"
author: "jpmckearin"

inputs:
  list-path:
    description: "Path to custom exploited packages list file. If not specified, uses the built-in list of known compromised packages. Example: 'security/custom-packages.txt'"
    required: false
    default: ""
  root-dir:
    description: "Root directory to scan for lockfiles. Scans recursively for package-lock.json, yarn.lock, pnpm-lock.yaml, and bun.lock files. Example: './src' or '.'"
    required: false
    default: "."
  managers:
    description: "Package managers to scan (comma-separated). Valid options: yarn, npm, pnpm, bun. Example: 'yarn,npm' to scan only Yarn and npm lockfiles."
    required: false
    default: "yarn,npm,pnpm,bun"
  include:
    description: "Glob patterns to include (comma-separated). Only scan paths matching these patterns. Example: 'src/**,apps/**' to scan only src and apps directories."
    required: false
  exclude:
    description: "Glob patterns to exclude (comma-separated). Skip paths matching these patterns. Example: '**/test/**,**/dist/**' to skip test and dist directories."
    required: false
  fail-on-match:
    description: "Whether to fail the workflow when compromised packages are found. Set to 'false' to only warn without failing the build."
    required: false
    default: "true"
  only-affected:
    description: "Show only compromised packages in output, hiding safe packages. Useful for focusing on actionable items only."
    required: false
    default: "false"
  summary:
    description: "Show only summary output without detailed package information. Useful for getting a quick overview of scan results."
    required: false
    default: "false"
  quiet:
    description: "Suppress non-essential output including clean package listings. Only shows compromised packages and warnings."
    required: false
    default: "false"
  no-color:
    description: "Disable colored output. Useful when output will be processed by tools that don't handle ANSI color codes."
    required: false
    default: "false"

outputs:
  has-matches:
    description: "Whether any compromised packages were found"
    value: ${{ steps.scan.outputs.has-matches }}
  match-count:
    description: "Number of compromised packages found"
    value: ${{ steps.scan.outputs.match-count }}
  warning-count:
    description: "Number of packages with vulnerable versions available"
    value: ${{ steps.scan.outputs.warning-count }}
  json-output:
    description: "JSON output of scan results"
    value: ${{ steps.scan.outputs.json-output }}

runs:
  using: "composite"
  steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Setup Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.22'

    - name: Cache Go modules
      uses: actions/cache@v4
      with:
        path: |
          ~/.cache/go-build
          ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-

    - name: Download scanner binary
      id: download
      shell: bash
      run: |
        # Determine platform and architecture
        case "${RUNNER_OS}" in
          "Linux")
            BINARY_NAME="scanner-linux-amd64"
            ;;
          "macOS")
            if [[ "${RUNNER_ARCH}" == "ARM64" ]]; then
              BINARY_NAME="scanner-macos-arm64"
            else
              BINARY_NAME="scanner-macos-amd64"
            fi
            ;;
          "Windows")
            BINARY_NAME="scanner-windows-amd64.exe"
            ;;
          *)
            echo "âŒ Unsupported platform: ${RUNNER_OS}"
            exit 1
            ;;
        esac

        echo "ðŸ”¨ Building scanner for ${RUNNER_OS}/${RUNNER_ARCH}..."

        # Build with optimizations
        if [[ "${RUNNER_OS}" == "Windows" ]]; then
          go build -ldflags="-s -w" -o "${BINARY_NAME}" scanner.go
        else
          go build -ldflags="-s -w" -o "${BINARY_NAME}" scanner.go
          chmod +x "${BINARY_NAME}"
        fi

        # Verify binary works
        if [[ ! -f "${BINARY_NAME}" ]]; then
          echo "âŒ Build failed - binary not found"
          exit 1
        fi

        echo "âœ… Binary built successfully: ${BINARY_NAME}"
        echo "binary_name=${BINARY_NAME}" >> $GITHUB_OUTPUT

    - name: Run shai-hulud-scanner
      id: scan
      shell: bash
      run: |
        BINARY_NAME="${{ steps.download.outputs.binary_name }}"

        # Build command arguments
        ARGS="--root-dir ${{ inputs.root-dir }} --json"

        # Add list-path if provided, otherwise use embedded file
        if [[ -n "${{ inputs.list-path }}" ]]; then
          ARGS="$ARGS --list-path ${{ inputs.list-path }}"
        fi

        if [[ -n "${{ inputs.managers }}" ]]; then
          ARGS="$ARGS --managers ${{ inputs.managers }}"
        fi

        if [[ -n "${{ inputs.include }}" ]]; then
          ARGS="$ARGS --include ${{ inputs.include }}"
        fi

        if [[ -n "${{ inputs.exclude }}" ]]; then
          ARGS="$ARGS --exclude ${{ inputs.exclude }}"
        fi

        if [[ "${{ inputs.only-affected }}" == "true" ]]; then
          ARGS="$ARGS --only-affected"
        fi

        if [[ "${{ inputs.summary }}" == "true" ]]; then
          ARGS="$ARGS --summary"
        fi

        if [[ "${{ inputs.quiet }}" == "true" ]]; then
          ARGS="$ARGS --quiet"
        fi

        if [[ "${{ inputs.no-color }}" == "true" ]]; then
          ARGS="$ARGS --no-color"
        fi

        echo "Running shai-hulud-scanner..."
        echo "Command: ./$BINARY_NAME $ARGS"

        # Run the scanner
        JSON_OUTPUT=$(./$BINARY_NAME $ARGS 2>&1)
        EXIT_CODE=$?

        echo "Scanner exit code: $EXIT_CODE"

        # Parse JSON output
        if [[ $EXIT_CODE -eq 0 ]] || [[ $EXIT_CODE -eq 2 ]]; then
          # Extract values from JSON
          HAS_MATCHES=$(echo "$JSON_OUTPUT" | jq -r '.anyAffected // false')
          MATCH_COUNT=$(echo "$JSON_OUTPUT" | jq -r '.summary.totalCompromised // 0')
          WARNING_COUNT=$(echo "$JSON_OUTPUT" | jq -r '.summary.totalWarnings // 0')

          # Set outputs
          echo "has-matches=$HAS_MATCHES" >> $GITHUB_OUTPUT
          echo "match-count=$MATCH_COUNT" >> $GITHUB_OUTPUT
          echo "warning-count=$WARNING_COUNT" >> $GITHUB_OUTPUT
          echo "json-output=$JSON_OUTPUT" >> $GITHUB_OUTPUT

          # Create step summary
          {
            echo "# ðŸ›¡ï¸ Package Security Scan Results"
            echo ""

            if [[ "$HAS_MATCHES" == "true" ]]; then
              echo "## âŒ Compromised Packages Found"
              echo ""
              echo "**$MATCH_COUNT compromised packages detected**"
              echo ""

              # List compromised packages
              if [[ "$MATCH_COUNT" -gt 0 ]]; then
                echo "| Package | Version | File |"
                echo "|---------|---------|------|"
                echo "$JSON_OUTPUT" | jq -r '.results[] | .packages[] | select(.isAffected == true) | "| `\(.package)` | `\(.version)` | `\(.lockFile)` |"' | sort -u
              fi
            elif [[ "$WARNING_COUNT" -gt 0 ]]; then
              echo "## âš ï¸ Warning: Vulnerable Versions Available"
              echo ""
              echo "**$WARNING_COUNT packages have vulnerable versions available (current versions are safe)**"
              echo ""

              if [[ "$WARNING_COUNT" -gt 0 ]]; then
                echo "| Package | Current Version | File |"
                echo "|---------|-----------------|------|"
                echo "$JSON_OUTPUT" | jq -r '.results[] | .packages[] | select(.isWarning == true) | "| `\(.package)` | `\(.version)` | `\(.lockFile)` |"' | sort -u
              fi
            else
              echo "## âœ… All Clear"
              echo ""
              echo "No compromised packages found. All packages are using safe versions."
              echo ""
            fi

            echo ""
            echo "## ðŸ“Š Scan Summary"
            echo ""
            echo "- **Lockfiles scanned:** $(echo "$JSON_OUTPUT" | jq -r '.summary.totalLockfiles // 0')"
            echo "- **Package entries checked:** $(echo "$JSON_OUTPUT" | jq -r '.summary.totalPackages // 0')"
            echo "- **Compromised packages:** $MATCH_COUNT"
            echo "- **Warning packages:** $WARNING_COUNT"
            echo ""

          } >> $GITHUB_STEP_SUMMARY

          # Handle results based on exit code
          if [[ $EXIT_CODE -eq 2 ]]; then
            if [[ "${{ inputs.fail-on-match }}" == "true" ]]; then
              echo "âŒ Security scan failed: $MATCH_COUNT compromised packages detected!"
              echo "Affected packages:"
              echo "$JSON_OUTPUT" | jq -r '.results[] | .packages[] | select(.isAffected == true) | "   - \(.package)@\(.version)"'
              exit 2
            else
              echo "âš ï¸ Security scan completed with $MATCH_COUNT compromised packages detected"
              echo "Affected packages:"
              echo "$JSON_OUTPUT" | jq -r '.results[] | .packages[] | select(.isAffected == true) | "   - \(.package)@\(.version)"'
            fi
          elif [[ "$WARNING_COUNT" -gt 0 ]]; then
            echo "âœ… Security scan passed: No compromised packages detected"
            echo "âš ï¸ Note: $WARNING_COUNT packages have vulnerable versions available (current versions are safe):"
            echo "$JSON_OUTPUT" | jq -r '.results[] | .packages[] | select(.isWarning == true) | "   - \(.package)@\(.version)"'
          else
            echo "âœ… Security scan passed: No compromised packages detected"
          fi

        else
          echo "âŒ Scanner failed with exit code $EXIT_CODE"
          echo "Output: $JSON_OUTPUT"
          echo "has-matches=false" >> $GITHUB_OUTPUT
          echo "match-count=0" >> $GITHUB_OUTPUT
          echo "warning-count=0" >> $GITHUB_OUTPUT
          echo "json-output=" >> $GITHUB_OUTPUT
          exit 1
        fi
